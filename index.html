<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumping Game</title>
    <!-- Tailwind CSS for styling the UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        /* Base styles for a full-viewport responsive layout */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #a0c9e6; /* Lighter background for morning theme */
            color: #2d3748;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        #game-container {
            flex-grow: 1; /* This is key to making the canvas take up available space */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 1rem;
        }
        
        @media (min-width: 768px) {
             #game-container {
                 padding-bottom: 80px; /* Space for the fixed control bar on desktop */
             }
        }
        
        @media (max-width: 767px) {
             #game-container {
                 padding-bottom: 120px; /* More space for the control bar on mobile */
            }
        }

        /* Canvas will now resize with the container */
        canvas {
            background: #a0c9e6; /* Match body background */
            border-radius: 1rem;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 40px rgba(0, 255, 255, 0.2);
            touch-action: none;
            width: 95%;
            flex: 1; /* Allow canvas to grow and take up remaining space */
            max-width: 900px;
        }

        /* Modal message box for game over */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(5px);
            padding: 2rem;
            border-radius: 1rem;
            border: 2px solid #4299e1;
            box-shadow: 0 0 15px rgba(66, 153, 225, 0.6);
            text-align: center;
            display: none;
            z-index: 10;
        }

        #message-box h2 {
            font-size: clamp(1.5rem, 5vw, 2.5rem); /* Responsive font size */
            margin: 0;
            color: #fff;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
        }

        #message-box p {
            margin: 1rem 0 0;
            font-size: clamp(1rem, 3vw, 1.2rem); /* Responsive font size */
            color: #e2e8f0;
        }

        .dropdown-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2d3748;
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 100;
            padding: 1rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 250px;
        }

        .dropdown-menu.visible {
            display: flex;
        }
        
        .file-input-label {
            display: block;
            background: #4a5568;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s;
            font-size: 0.875rem;
        }

        .file-input-label:hover {
            background-color: #718096;
        }

        .difficulty-button {
            background-color: #e2e8f0;
            color: #2d3748;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.875rem;
        }

        .difficulty-button.active {
            background-color: #4299e1;
            color: white;
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.4);
        }

        .game-button {
            background: linear-gradient(145deg, #f6e05e, #d69e2e);
            color: #2d3748;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
            box-shadow: 0 4px 15px rgba(246, 224, 94, 0.4);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.875rem;
            white-space: nowrap; /* Prevent buttons from wrapping text */
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(246, 224, 94, 0.6);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(246, 224, 94, 0.4);
        }
        
        /* New responsive classes for the bottom control bar */
        .bottom-control-bar {
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }
        @media (min-width: 768px) {
            .bottom-control-bar {
                flex-direction: row;
                justify-content: space-between;
                gap: 0;
            }
        }

        /* Style for the character image on the game over screen */
        #characterImageMessage {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid #fff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            margin-bottom: 1rem;
            object-fit: cover;
        }
    </style>
</head>
<body class="bg-[#a0c9e6] text-[#2d3748]">

    <div id="game-container" class="w-full flex-grow flex flex-col items-center">
        <h1 class="text-3xl md:text-5xl font-bold text-center mb-1 text-[#4299e1] uppercase tracking-wider mt-4">Jumping Game</h1>
        
        <canvas id="gameCanvas" class="w-full h-full rounded-2xl shadow-xl border-4 border-[#4299e1]"></canvas>

        <div id="message-box" class="flex items-center justify-center">
            <div class="bg-gray-900 p-8 rounded-2xl shadow-2xl text-center border-4 border-blue-500 flex flex-col items-center">
                <img id="characterImageMessage" src="" alt="Main Character" class="hidden">
                <h2 class="text-4xl text-white mb-4"></h2>
                <p class="text-xl text-gray-300"></p>
                <button id="restartBtnMessage" class="game-button mt-6">Play Again</button>
            </div>
        </div>
    </div>

    <!-- The new fixed control bar at the bottom with improved responsiveness -->
    <div class="fixed bottom-0 left-0 right-0 p-4 bg-slate-800 rounded-t-lg shadow-lg">
        <div class="container mx-auto flex bottom-control-bar">

            <!-- Bottom Left: Choose Character Image -->
            <div class="relative flex-1 text-center">
                <button id="imageMenuBtn" class="game-button">Choose Character</button>
                <div id="imageMenu" class="dropdown-menu">
                    <input type="file" id="char-image-upload" class="hidden" accept="image/*" data-char="main">
                    <label for="char-image-upload" class="file-input-label">Upload Main Character</label>

                    <input type="file" id="hr-image-upload" class="hidden" accept="image/*" data-char="HR">
                    <label for="hr-image-upload" class="file-input-label">Upload HR</label>

                    <input type="file" id="am-image-upload" class="hidden" accept="image/*" data-char="Associate Manager">
                    <label for="am-image-upload" class="file-input-label">Upload AM</label>

                    <input type="file" id="pm-image-upload" class="hidden" accept="image/*" data-char="Project Manager">
                    <label for="pm-image-upload" class="file-input-label">Upload PM</label>

                    <input type="file" id="ceo-image-upload" class="hidden" accept="image/*" data-char="CEO">
                    <label for="ceo-image-upload" class="file-input-label">Upload CEO</label>
                </div>
            </div>

            <!-- Center: Difficulty buttons -->
            <div id="difficulty-container" class="flex-1 flex items-center justify-center space-x-2 sm:space-x-4">
                <button class="difficulty-button active" data-mode="easy">Easy</button>
                <button class="difficulty-button" data-mode="medium">Medium</button>
                <button class="difficulty-button" data-mode="hard">Hard</button>
            </div>

            <!-- Bottom Right: Game control buttons -->
            <div class="flex-1 flex items-center justify-center space-x-4">
                <button id="startBtn" class="game-button">Start Game</button>
                <button id="restartBtn" class="game-button hidden">Restart Game</button>
            </div>
        </div>
    </div>

    <script>
        // Use a function to encapsulate the game logic
        function setupGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const fileInputs = document.querySelectorAll('input[type="file"]');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const messageBox = document.getElementById('message-box');
            const characterImageMessage = document.getElementById('characterImageMessage');
            const messageTitle = messageBox.querySelector('h2');
            const messageText = messageBox.querySelector('p');
            const restartBtnMessage = document.getElementById('restartBtnMessage');
            const difficultyButtons = document.querySelectorAll('.difficulty-button');
            const imageMenuBtn = document.getElementById('imageMenuBtn');
            const imageMenu = document.getElementById('imageMenu');

            let gameStarted = false;
            let gameOver = false;
            let gravity = 0.5;
            let gameSpeed = 3;
            let score = 0;
            let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
            let frameCount = 0;
            let gameMode = 'medium';

            let boostScoreMultiplier = 1;
            let appraisalBoostTimer = 0;
            let promotionBoostTimer = 0;
            let boostMessage = null;
            let boostMessageTimer = 0;
            const boostMessageDuration = 90;
            const boostDurationFrames = 600;

            let doubleJumpEnabled = false;
            let doubleJumpTimer = 0;
            const doubleJumpDuration = 600;

            let geminiMessage = null;
            let geminiMessageTimer = 0;
            const geminiMessageDuration = 180;

            // Character and object data
            let character = {};
            let platforms = [];
            let enemies = [];
            let powerups = [];
            let particles = [];
            let treePositions = [];
            let lastPlatformX = 0;

            // Image objects for all characters
            let characterImages = {
                'main': new Image(),
                'HR': new Image(),
                'Associate Manager': new Image(),
                'Project Manager': new Image(),
                'CEO': new Image()
            };
            
            // Set initial image sources to placeholder URLs
            // Note: Images are drawn at sizes defined by the game, not their native resolution.
            // For example, the main character is always 70x70 pixels on the canvas.
            characterImages['main'].src = 'character.png';
            characterImages['HR'].src = 'HR.png';
            characterImages['Associate Manager'].src = 'AM.png';
            characterImages['Project Manager'].src = 'PM.png';
            characterImages['CEO'].src = 'https://placehold.co/40x40/1a202c/fff?text=CEO';

            // Total Screen Coverage variables
            let coverageGrid = [];
            const gridWidth = 50;
            const gridHeight = 25;
            let totalCoveredCells = 0;
            let cellWidth;
            let cellHeight;

            const ground = { height: 20 };
            
            // Function to handle fetching from Gemini API with retries
            async function getGeminiReview(powerupType) {
                const prompt = powerupType === 'Appraisal'
                    ? `Generate a single-sentence, humorous, corporate-themed appraisal message for a jumping game character who just got an 'Appraisal' power-up. Start the message with "Appraisal:".`
                    : `Generate a single-sentence, enthusiastic, corporate promotion announcement for a jumping game character who just got a 'Promotion' power-up. Start the message with "Promotion:".`;
                
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let retries = 0;
                const maxRetries = 5;
                const baseDelay = 1000;

                while (retries < maxRetries) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429 && retries < maxRetries - 1) { // 429 Too Many Requests
                                const delay = baseDelay * (2 ** retries) + Math.random() * 1000;
                                await new Promise(res => setTimeout(res, delay));
                                retries++;
                                continue;
                            }
                            throw new Error(`Gemini API Error: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            geminiMessage = result.candidates[0].content.parts[0].text;
                            geminiMessageTimer = geminiMessageDuration;
                        } else {
                            throw new Error("Gemini API response format is unexpected.");
                        }
                        return; // Exit the loop on success

                    } catch (error) {
                        console.error("Gemini API Error:", error);
                        // No retry for other errors, just the 429
                        break;
                    }
                }
            }
            
            // Game reset and initialization
            function resetGame() {
                gameOver = false;
                score = 0;
                lastPlatformX = 0;
                platforms = [];
                enemies = [];
                powerups = [];
                particles = [];
                treePositions = [];
                boostScoreMultiplier = 1;
                appraisalBoostTimer = 0;
                promotionBoostTimer = 0;
                boostMessage = null;
                boostMessageTimer = 0;
                doubleJumpEnabled = false;
                doubleJumpTimer = 0;
                
                character = {
                    x: 50,
                    y: canvas.height - ground.height - 70,
                    width: 70,
                    height: 70,
                    vx: 0,
                    vy: 0,
                    speed: 5,
                    jumpPower: -12,
                    jumps: 0,
                    isJumping: false,
                    onGround: false,
                    isFacingRight: true
                };

                resetCoverageGrid();
                hideMessage();
            }

            function resetCoverageGrid() {
                cellWidth = canvas.width / gridWidth;
                cellHeight = canvas.height / gridHeight;
                coverageGrid = [];
                for (let i = 0; i < gridHeight; i++) {
                    coverageGrid[i] = new Array(gridWidth).fill(0);
                }
                totalCoveredCells = 0;
            }

            // Function to handle canvas and character resizing
            function resizeHandler() {
                const container = canvas.parentElement;
                const controlsHeight = document.querySelector('.fixed.bottom-0').offsetHeight;
                const headerHeight = document.querySelector('h1').offsetHeight;
                const padding = 24;
                
                canvas.width = container.clientWidth;
                canvas.height = window.innerHeight - controlsHeight - headerHeight - padding;
                
                ground.y = canvas.height - ground.height;
                character.y = ground.y - character.height;

                resetCoverageGrid();
            }

            // Object generation
            function generateObjects() {
                while (lastPlatformX < canvas.width + 200) {
                    const minWidth = 80;
                    const maxWidth = 200;
                    const width = Math.random() * (maxWidth - minWidth) + minWidth;
                    const minHeight = 100;
                    const maxHeight = canvas.height * 0.7;
                    const height = Math.random() * (maxHeight - minHeight) + minHeight;
                    const gap = Math.random() * 200 + 100;
                    
                    platforms.push({ x: lastPlatformX + gap, y: canvas.height - height, width: width, height: height });
                    lastPlatformX = platforms[platforms.length - 1].x + platforms[platforms.length - 1].width;
                }

                if (Math.random() < 0.008) { 
                    const enemyTypeKeys = ['HR', 'Associate Manager', 'Project Manager', 'CEO'];
                    const randomKey = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                    const enemyImage = characterImages[randomKey];
                    // Fix: Set a fixed size for enemies (40x40) instead of using the image's original dimensions
                    enemies.push({
                        x: canvas.width,
                        y: ground.y - 40, // Use a fixed height for consistency
                        width: 40,
                        height: 40,
                        type: randomKey,
                        animOffset: Math.random() * Math.PI * 2
                    });
                }
                if (Math.random() < 0.01) {
                    const powerupType = Math.random() < 0.5 ? 'Appraisal' : 'Promotion';
                    powerups.push({
                        x: canvas.width + Math.random() * 100,
                        y: ground.y - 60 - Math.random() * 150,
                        width: 25,
                        height: 25,
                        type: powerupType,
                        color: powerupType === 'Appraisal' ? '#f6e05e' : '#4299e1',
                        animOffset: Math.random() * Math.PI * 2
                    });
                }
                if (treePositions.length < 5) {
                    if (treePositions.length === 0 || treePositions[treePositions.length-1].x < canvas.width * 0.8) {
                        treePositions.push({
                            x: canvas.width + Math.random() * 200,
                            size: Math.random() * 30 + 20
                        });
                    }
                }
            }
            
            // NEW function to show boost message
            function showBoostMessage(message) {
                boostMessage = message;
                boostMessageTimer = boostMessageDuration;
            }

            // Drawing functions
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawCoverageGrid();
                drawTrees();
                drawGround();
                drawPlatforms();
                drawEnemies();
                drawPowerups();
                drawParticles();
                drawCharacter();
                drawScore();
                drawGeminiMessage();
                drawBoostMessage();
                drawDoubleJumpIndicator();
            }

            function drawCharacter() {
                ctx.save();
                if (!character.isFacingRight) {
                    ctx.scale(-1, 1);
                    // The image is explicitly drawn at the fixed width and height of the `character` object
                    ctx.drawImage(characterImages['main'], -character.x - character.width, character.y, character.width, character.height);
                } else {
                    // The image is explicitly drawn at the fixed width and height of the `character` object
                    ctx.drawImage(characterImages['main'], character.x, character.y, character.width, character.height);
                }
                ctx.restore();
            }

            function drawGround() {
                ctx.fillStyle = '#4299e1';
                ctx.fillRect(0, ground.y, canvas.width, ground.height);
            }

            function drawPlatforms() {
                platforms.forEach(platform => {
                    ctx.fillStyle = '#2d3748';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    const windowSize = 8;
                    const windowGap = 10;
                    const windowColor = '#a0aec0';
                    ctx.fillStyle = windowColor;
                    for (let x = platform.x + windowGap; x < platform.x + platform.width - windowGap; x += windowSize + windowGap) {
                        for (let y = platform.y + windowGap; y < platform.y + platform.height - windowGap; y += windowSize + windowGap) {
                            ctx.fillRect(x, y, windowSize, windowSize);
                        }
                    }
                });
            }

            function drawTrees() {
                treePositions.forEach(tree => {
                    ctx.fillStyle = '#4a2c10';
                    ctx.fillRect(tree.x, ground.y - tree.size, tree.size / 4, tree.size);
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(tree.x + tree.size / 8, ground.y - tree.size * 1.2, tree.size / 1.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawEnemies() {
                enemies.forEach(enemy => {
                    const offsetY = Math.sin(frameCount * 0.05 + enemy.animOffset) * 5;
                    const enemyImage = characterImages[enemy.type];
                    if (enemyImage && enemyImage.complete && enemyImage.naturalWidth !== 0) {
                        // The enemy image is now drawn at the fixed width and height (40x40)
                        ctx.drawImage(enemyImage, enemy.x, enemy.y + offsetY, enemy.width, enemy.height);
                    } else {
                        // Fallback in case image hasn't loaded
                        ctx.fillStyle = '#1a202c';
                        ctx.fillRect(enemy.x, enemy.y + offsetY, enemy.width, enemy.height);
                    }
                    ctx.fillStyle = '#2d3748';
                    ctx.font = '10px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.type, enemy.x + enemy.width / 2, enemy.y + offsetY - 5);
                });
            }

            function drawPowerups() {
                powerups.forEach(powerup => {
                    const scale = 1 + Math.sin(frameCount * 0.1 + powerup.animOffset) * 0.1;
                    ctx.save();
                    ctx.translate(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2);
                    ctx.scale(scale, scale);
                    ctx.fillStyle = powerup.color;
                    ctx.beginPath();
                    const points = 5;
                    const outerRadius = powerup.width / 2;
                    const innerRadius = outerRadius / 2;
                    let rot = Math.PI / 2 * 3;
                    ctx.moveTo(0, 0 + outerRadius);
                    for(let i = 0; i < points; i++){
                        ctx.lineTo(0 + Math.cos(rot) * outerRadius, 0 + Math.sin(rot) * outerRadius);
                        rot += Math.PI / points;
                        ctx.lineTo(0 + Math.cos(rot) * innerRadius, 0 + Math.sin(rot) * innerRadius);
                        rot += Math.PI / points;
                    }
                    ctx.lineTo(0, 0 + outerRadius);
                    ctx.fill();
                    ctx.closePath();
                    ctx.restore();
                });
            }

            function drawScore() {
                ctx.fillStyle = '#2d3748';
                ctx.font = '16px "Press Start 2P"';
                ctx.textAlign = 'left';
                const currentMultiplier = (boostScoreMultiplier - 1) * 100;
                const boostText = currentMultiplier > 0 ? ` (+${Math.round(currentMultiplier)}%)` : '';
                ctx.fillText(`Score: ${Math.floor(score)}${boostText}`, 10, 25);
                ctx.textAlign = 'right';
                ctx.fillText(`High Score: ${highScore}`, canvas.width - 10, 25);
            }

            function drawCoverageGrid() {
                ctx.save();
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#f6e05e';
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (coverageGrid[y][x] === 1) {
                            ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                ctx.restore();
            }

            function drawParticles() {
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${p.color === 'white' ? '255, 255, 255' : '255, 215, 0'}, ${p.alpha})`;
                    ctx.fill();
                    ctx.closePath();
                });
            }

            function drawGeminiMessage() {
                if (geminiMessage && geminiMessageTimer > 0) {
                    ctx.save();
                    const alpha = Math.min(1, geminiMessageTimer / 60);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(5, 40, canvas.width - 10, 30);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(geminiMessage, canvas.width / 2, 60);
                    ctx.restore();
                }
            }

            function drawBoostMessage() {
                if (boostMessage && boostMessageTimer > 0) {
                    ctx.save();
                    const alpha = Math.min(1, boostMessageTimer / 30);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '24px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(boostMessage, canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                }
            }

            function drawDoubleJumpIndicator() {
                if (doubleJumpEnabled && doubleJumpTimer > 0) {
                    const radius = 50;
                    const x = 75;
                    const y = canvas.height / 2;
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (doubleJumpTimer / doubleJumpDuration) * (Math.PI * 2);
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, radius, startAngle, endAngle, false);
                    ctx.lineTo(x, y);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(66, 153, 225, 0.9)';
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('DOUBLE', x, y + 8);
                }
            }

            // Update game state
            function update() {
                if (gameOver) return;

                // Move character
                character.vy += gravity;
                character.y += character.vy;
                character.x += character.vx;

                // Update game objects
                platforms.forEach(p => p.x -= gameSpeed);
                enemies.forEach(e => {
                    e.x -= gameSpeed;
                    e.y = ground.y - e.height + Math.sin(frameCount * 0.05 + e.animOffset) * 5;
                });
                powerups.forEach(p => p.x -= gameSpeed);
                treePositions.forEach(t => t.x -= gameSpeed * 0.5);

                // Filter off-screen objects
                platforms = platforms.filter(p => p.x + p.width > 0);
                enemies = enemies.filter(e => e.x + e.width > 0);
                powerups = powerups.filter(p => p.x + p.width > 0);
                treePositions = treePositions.filter(t => t.x + t.size > 0);
                
                // Score based on screen coverage
                const gridX = Math.floor((character.x + character.width / 2) / cellWidth);
                const gridY = Math.floor((character.y + character.height / 2) / cellHeight);
                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                    if (coverageGrid[gridY][gridX] === 0) {
                        coverageGrid[gridY][gridX] = 1;
                        totalCoveredCells++;
                    }
                }
                score = totalCoveredCells * boostScoreMultiplier;
                
                // Character collisions
                let onAnyPlatform = false;
                if (character.y + character.height >= ground.y) {
                    onAnyPlatform = true;
                    character.y = ground.y - character.height;
                    character.vy = 0;
                    character.jumps = 0;
                }
                platforms.forEach(p => {
                    if (
                        character.x < p.x + p.width && character.x + character.width > p.x &&
                        character.y + character.height <= p.y + character.vy && character.y + character.height + character.vy >= p.y
                    ) {
                        character.y = p.y - character.height;
                        character.vy = 0;
                        character.jumps = 0;
                        onAnyPlatform = true;
                    }
                });
                character.onGround = onAnyPlatform;

                if (!character.onGround && character.y > canvas.height) {
                    endGame('Game Over!', `You fell! Your final score is ${Math.floor(score)}.`);
                    return;
                }

                enemies.forEach(e => {
                    if (character.x < e.x + e.width && character.x + character.width > e.x &&
                        character.y < e.y + e.height && character.y + character.height > e.y) {
                        endGame('Game Over!', `You were caught by the ${e.type}! Your final score is ${Math.floor(score)}.`);
                        return;
                    }
                });

                powerups = powerups.filter(p => {
                    if (character.x < p.x + p.width && character.x + character.width > p.x &&
                        character.y < p.y + p.height && character.y + character.height > p.y) {
                        if (p.type === 'Appraisal') {
                            const boosts = [0.05, 0.10, 0.15];
                            const boost = boosts[Math.floor(Math.random() * boosts.length)];
                            boostScoreMultiplier = 1 + boost;
                            appraisalBoostTimer = boostDurationFrames;
                            showBoostMessage(`Appraisal - ${Math.round(boost * 100)}% Boost`);
                            getGeminiReview('Appraisal');
                        } else if (p.type === 'Promotion') {
                            const boost = 0.35;
                            boostScoreMultiplier = 1 + boost;
                            promotionBoostTimer = boostDurationFrames;
                            showBoostMessage(`Promotion - ${Math.round(boost * 100)}% Boost`);
                            getGeminiReview('Promotion');
                            doubleJumpEnabled = true;
                            doubleJumpTimer = doubleJumpDuration;
                        }
                        return false;
                    }
                    return true;
                });

                // Update timers and effects
                if (geminiMessageTimer > 0) geminiMessageTimer--; else geminiMessage = null;
                if (appraisalBoostTimer > 0) appraisalBoostTimer--; else if (promotionBoostTimer > 0) promotionBoostTimer--; else boostScoreMultiplier = 1;
                if (boostMessageTimer > 0) boostMessageTimer--; else boostMessage = null;
                if (doubleJumpEnabled && doubleJumpTimer > 0) doubleJumpTimer--; else doubleJumpEnabled = false;

                // Particle effects
                if (character.vx !== 0 && character.onGround) {
                    particles.push({
                        x: character.isFacingRight ? character.x : character.x + character.width,
                        y: character.y + character.height - 5,
                        vx: character.isFacingRight ? -gameSpeed * 0.5 : gameSpeed * 0.5,
                        vy: -Math.random() * 2,
                        size: Math.random() * 5 + 2,
                        alpha: 1,
                        color: 'white'
                    });
                }
                particles.forEach(p => { p.x += p.vx - gameSpeed; p.y += p.vy; p.alpha -= 0.02; });
                particles = particles.filter(p => p.alpha > 0);

                frameCount++;
            }

            // Game loop
            function gameLoop() {
                if (gameStarted && !gameOver) {
                    generateObjects();
                    update();
                    draw();
                } else if (!gameStarted) {
                    // Draw start screen state
                    draw();
                }
                requestAnimationFrame(gameLoop);
            }

            // UI and event handlers
            function showMessage(title, text) {
                messageTitle.textContent = title;
                messageText.textContent = text;
                characterImageMessage.src = characterImages['main'].src;
                characterImageMessage.classList.remove('hidden');
                messageBox.style.display = 'flex';
                restartBtn.classList.remove('hidden');
                startBtn.classList.add('hidden');
            }

            function hideMessage() {
                messageBox.style.display = 'none';
                characterImageMessage.classList.add('hidden');
            }

            function endGame(title, text) {
                gameOver = true;
                gameStarted = false;
                if (Math.floor(score) > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('highScore', highScore);
                    showMessage('New High Score!', `You set a new record with ${highScore} points!`);
                } else {
                    showMessage(title, text);
                }
            }
            
            // Image upload handlers
            fileInputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    const charType = e.target.dataset.char;
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            if (characterImages[charType]) {
                                characterImages[charType].src = event.target.result;
                            }
                            showMessage("Image Loaded", `The image for ${charType} is ready.`);
                        };
                        reader.readAsDataURL(file);
                    }
                });
            });

            // Input handlers
            document.addEventListener('keydown', (e) => {
                if (gameOver) return;
                if (e.key === 'ArrowRight') { character.vx = character.speed; character.isFacingRight = true; }
                else if (e.key === 'ArrowLeft') { character.vx = -character.speed; character.isFacingRight = false; }
                else if (e.key === ' ' || e.key === 'ArrowUp') {
                    if (character.onGround) {
                        character.vy = character.jumpPower;
                        character.onGround = false;
                        character.jumps = 1;
                    } else if (doubleJumpEnabled && character.jumps < 2) {
                        character.vy = character.jumpPower;
                        character.jumps++;
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') character.vx = 0;
            });
            
            // Mouse/touch for jump
            canvas.addEventListener('click', () => {
                 if (gameOver) return;
                 if (character.onGround) {
                    character.vy = character.jumpPower;
                    character.onGround = false;
                    character.jumps = 1;
                 } else if (doubleJumpEnabled && character.jumps < 2) {
                    character.vy = character.jumpPower;
                    character.jumps++;
                 }
            });

            // UI button handlers
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficultyButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameMode = btn.dataset.mode;
                    switch(gameMode) {
                        case 'easy': gameSpeed = 2; break;
                        case 'medium': gameSpeed = 3; break;
                        case 'hard': gameSpeed = 5; break;
                    }
                });
            });
            imageMenuBtn.addEventListener('click', () => { imageMenu.classList.toggle('visible'); });
            document.addEventListener('click', (event) => {
                if (!imageMenuBtn.contains(event.target) && !imageMenu.contains(event.target)) {
                    imageMenu.classList.remove('visible');
                }
            });
            startBtn.addEventListener('click', () => { if (!gameStarted) { gameStarted = true; resetGame(); } });
            restartBtn.addEventListener('click', () => { gameStarted = true; resetGame(); });
            restartBtnMessage.addEventListener('click', () => { gameStarted = true; resetGame(); });
            
            // Initial setup
            window.addEventListener('resize', resizeHandler);
            resizeHandler();
            resetGame();
            gameLoop();
        }

        window.onload = setupGame;
    </script>
</body>
</html>
